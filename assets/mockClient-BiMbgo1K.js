const P=new Map,h=[{symbol:"HYPE",name:"Hyperliquid",baseAsset:"HYPE",quoteAsset:"USDC",pricePrecision:2,sizePrecision:4,minSize:.01,maxSize:1e6,maxLeverage:5},{symbol:"BTC",name:"Bitcoin",baseAsset:"BTC",quoteAsset:"USDC",pricePrecision:2,sizePrecision:6,minSize:1e-4,maxSize:1e3,maxLeverage:5},{symbol:"ETH",name:"Ethereum",baseAsset:"ETH",quoteAsset:"USDC",pricePrecision:2,sizePrecision:4,minSize:.001,maxSize:1e4,maxLeverage:5},{symbol:"SOL",name:"Solana",baseAsset:"SOL",quoteAsset:"USDC",pricePrecision:3,sizePrecision:2,minSize:.1,maxSize:1e5,maxLeverage:5}],f={HYPE:1.5,BTC:45e3,ETH:2500,SOL:100},y=e=>{const o=e==="HYPE"?1.5:e==="BTC"?45e3:e==="ETH"?2500:100,s=[],t=[];for(let i=0;i<10;i++)s.push({price:o*(1-(i+1)*.001),size:Math.random()*100+10}),t.push({price:o*(1+(i+1)*.001),size:Math.random()*100+10});return{bids:s.sort((i,r)=>r.price-i.price),asks:t.sort((i,r)=>i.price-r.price),timestamp:Date.now()}},S=e=>{const o=e==="HYPE"?1.5:e==="BTC"?45e3:e==="ETH"?2500:100,s=[];for(let t=0;t<20;t++)s.push({id:`trade-${e}-${t}`,price:o*(1+(Math.random()-.5)*.01),size:Math.random()*50+1,side:Math.random()>.5?"buy":"sell",timestamp:Date.now()-t*1e3,explorer:""});return s.sort((t,i)=>i.timestamp-t.timestamp)},g=new Map,w=(e,o=!0)=>{if(!e||e==="")return[];const s=Date.now();let t=g.get(e);if(!t){const i=[];if(o){const r=["HYPE","BTC"];for(let n=0;n<2;n++){const a=r[n],c=n%2===0?"long":"short",m=(a==="HYPE"?1.5:a==="BTC"?45e3:1800)*(1+(Math.random()-.5)*.02);i.push({id:`pos-${e}-${a}-stable`,market:`${a}-USD`,side:c,size:Math.random()*5+.5,entryPrice:m,markPrice:m,liquidationPrice:m*(1-(c==="long"?.15:-.15)/5),unrealizedPnl:0,realizedPnl:0,leverage:5,timestamp:s,positionValue:0})}}t={positions:i,createdAt:s,lastPriceUpdate:s,lastNewPositionCheck:s,closedPositionIds:new Set},g.set(e,t)}return s-t.lastPriceUpdate>=2e3&&(t.positions=t.positions.map(i=>{const r=(Math.random()-.5)*.01,n=i.markPrice*(1+r),a=(n-i.entryPrice)*i.size*(i.side==="long"?1:-1);return{...i,markPrice:n,unrealizedPnl:a,positionValue:i.size*n}}),t.lastPriceUpdate=s),t.positions.filter(i=>!t.closedPositionIds.has(i.id))},k=e=>{const o=w(e),s=1e7+o.reduce((i,r)=>i+r.unrealizedPnl,0),t=o.reduce((i,r)=>i+r.size*r.entryPrice,0);return{address:e,balances:[{asset:"USDC",total:s,available:s-t,inPositions:t}],totalEquity:s,freeCollateral:s-t}},C=()=>{const e={};return h.forEach(o=>{const s=f[o.symbol],t=s*(1+(Math.random()-.5)*.02),i=t-s;e[o.symbol]={lastPrice:t,volume24h:Math.floor(Math.random()*1e4+1e3),funding:(Math.random()-.5)*.05,openInterest:Math.floor(Math.random()*5e3+1e3),change24hPct:i/s*100,change24hAbs:i}}),e},u=new Map,$=(e,o,s,t,i)=>{const r=s==="buy",n=r?"long":"short",a=i||45e3,c=a*(1+(Math.random()-.5)*.01);return{id:`order-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,market:o.includes("-")?o:`${o}-USD`,side:n,size:t,entryPrice:i||a,markPrice:c,liquidationPrice:(i||a)*(1-(r?.1:-.1)/5),unrealizedPnl:0,realizedPnl:0,leverage:5,timestamp:Date.now(),positionValue:t*i}},T={async getMarkets(){return await new Promise(e=>setTimeout(e,100)),[...h]},async getMarketStats(){return await new Promise(e=>setTimeout(e,100)),C()},async getOrderBook(e){return await new Promise(o=>setTimeout(o,100)),y(e)},async getTrades(e,o=20){return await new Promise(s=>setTimeout(s,100)),S(e).slice(0,o)},async getPositions(e){await new Promise(t=>setTimeout(t,100));const o=u.get(e)||[],s=o.map(t=>t.position);if(s.length>0){console.log(`[MOCK-getPositions] User ${e.slice(0,6)}... - Found ${s.length} copied positions`);const t=s.map(r=>{const n=(Math.random()-.5)*.01,a=r.markPrice*(1+n),c=(a-r.entryPrice)*r.size*(r.side==="long"?1:-1),d={...r,markPrice:a,unrealizedPnl:c,positionValue:r.size*a};return console.log(`[MOCK-getPositions] Updated ${r.market}: Mark ${r.markPrice.toFixed(4)} â†’ ${a.toFixed(4)}`),d}),i=o.map((r,n)=>({...r,position:t[n]}));return u.set(e,i),t}if(b(e)){const t=w(e,!0);return console.log(`[MOCK-getPositions] Trader ${e.slice(0,6)}... - Generated ${t.length} positions`),t}return console.log(`[MOCK-getPositions] User ${e.slice(0,6)}... - No positions`),[]},async getAccountInfo(e){return await new Promise(o=>setTimeout(o,100)),k(e)},createExchangeClient(e){const o=e?.address||"0xmock";return{order:async s=>(console.log("[MOCK-EXCHANGE] order() called with orders:",s),T.order(o,s)),modifyOrder:async s=>({status:"ok",response:[]}),cancelOrder:async s=>({status:"ok",response:[]}),updateLeverage:async()=>({status:"ok"}),updateIsolatedMargin:async()=>({status:"ok"})}},async getUserFills(e,o=!0){return await new Promise(s=>setTimeout(s,100)),[]},async getExtraAgents(e){return await new Promise(o=>setTimeout(o,100)),{}},async storeOrder(e,o){const s=P.get(e)||[];s.push({...o,id:`order-${Date.now()}-${Math.random().toString(36).substring(2,11)}`,status:"pending",timestamp:Date.now()}),P.set(e,s)},async order(e,o){console.log(`[MOCK-order] Called for address=${e.slice(0,6)}... with ${o.length} orders`),await new Promise(t=>setTimeout(t,200));const s=[];for(const t of o){const i=`order-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;console.log("[MOCK-order] Processing orderConfig:",JSON.stringify(t).slice(0,200));let r="BTC-USD",n="buy",a=1,c=45e3;if(t.t){const l=t.t;l.asset!==void 0&&(r=`ASSET${l.asset}-USD`),l.isBuy!==void 0&&(n=l.isBuy?"buy":"sell"),l.sz!==void 0&&(a=l.sz),l.px!==void 0&&(c=l.px)}else t.market&&(r=t.market.includes("-")?t.market:`${t.market}-USD`),t.side&&(n=t.side==="long"||t.side==="buy"?"buy":"sell"),t.size!==void 0&&(a=t.size),t.price!==void 0&&(c=t.price);r.includes("-")||(r=`${r}-USD`),console.log(`[MOCK-order] Extracted: market=${r}, side=${n}, size=${a}, price=${c}`);const d=$(e,r,n,a,c),m=u.get(e)||[],M=n==="buy"?"long":"short",p=m.findIndex(l=>l.position.market===r&&l.position.side===M);p!==-1?(m[p]={orderId:i,position:d,timestamp:Date.now()},console.log(`[MOCK-order] Position UPDATED: ${d.market} ${d.side} (replaced existing), total positions for address now=${m.length}`)):(m.push({orderId:i,position:d,timestamp:Date.now()}),console.log(`[MOCK-order] Position STORED: ${d.market} ${d.side} size=${d.size}, total positions for address now=${m.length}`)),u.set(e,m),s.push({status:"ok",response:{type:"order",oid:i,statuses:["filled"]}})}return console.log(`[MOCK-order] Returning success for ${s.length} orders`),{status:"ok",response:s}},async getOrders(e){return await new Promise(o=>setTimeout(o,100)),P.get(e)||[]},clearOrders(e){e?P.delete(e):P.clear()},closePosition(e,o){const s=g.get(e);s&&(s.closedPositionIds.add(o),console.log(`[MOCK-closePosition] Closed position ${o} for ${e.slice(0,6)}... (will stay closed)`));const i=(u.get(e)||[]).filter(r=>r.position.id!==o);i.length>0?u.set(e,i):u.delete(e)}},z=[{address:"0x1111111111111111111111111111111111111111",name:"ProTrader",leverage:5,riskPerTrade:2},{address:"0x2222222222222222222222222222222222222222",name:"SwingTrader",leverage:3,riskPerTrade:1.5},{address:"0x3333333333333333333333333333333333333333",name:"ScalpMaster",leverage:2,riskPerTrade:1}],b=e=>z.some(o=>o.address.toLowerCase()===e.toLowerCase());export{T as mockClient};

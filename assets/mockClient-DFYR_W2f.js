const P=new Map,w=[{symbol:"HYPE",name:"Hyperliquid",baseAsset:"HYPE",quoteAsset:"USDC",pricePrecision:2,sizePrecision:4,minSize:.01,maxSize:1e6,maxLeverage:5},{symbol:"BTC",name:"Bitcoin",baseAsset:"BTC",quoteAsset:"USDC",pricePrecision:2,sizePrecision:6,minSize:1e-4,maxSize:1e3,maxLeverage:5},{symbol:"ETH",name:"Ethereum",baseAsset:"ETH",quoteAsset:"USDC",pricePrecision:2,sizePrecision:4,minSize:.001,maxSize:1e4,maxLeverage:5},{symbol:"SOL",name:"Solana",baseAsset:"SOL",quoteAsset:"USDC",pricePrecision:3,sizePrecision:2,minSize:.1,maxSize:1e5,maxLeverage:5}],y={HYPE:1.5,BTC:45e3,ETH:2500,SOL:100},S=e=>{const s=e==="HYPE"?1.5:e==="BTC"?45e3:e==="ETH"?2500:100,o=[],t=[];for(let i=0;i<10;i++)o.push({price:s*(1-(i+1)*.001),size:Math.random()*100+10}),t.push({price:s*(1+(i+1)*.001),size:Math.random()*100+10});return{bids:o.sort((i,r)=>r.price-i.price),asks:t.sort((i,r)=>i.price-r.price),timestamp:Date.now()}},k=e=>{const s=e==="HYPE"?1.5:e==="BTC"?45e3:e==="ETH"?2500:100,o=[];for(let t=0;t<20;t++)o.push({id:`trade-${e}-${t}`,price:s*(1+(Math.random()-.5)*.01),size:Math.random()*50+1,side:Math.random()>.5?"buy":"sell",timestamp:Date.now()-t*1e3,explorer:""});return o.sort((t,i)=>i.timestamp-t.timestamp)},g=new Map,f=(e,s=!0)=>{if(!e||e==="")return[];const o=Date.now();let t=g.get(e);if(!t){const i=[];if(s){const r=["HYPE","BTC"];for(let n=0;n<2;n++){const a=r[n],c=n%2===0?"long":"short",m=(a==="HYPE"?1.5:a==="BTC"?45e3:1800)*(1+(Math.random()-.5)*.02);i.push({id:`pos-${e}-${a}-stable`,market:`${a}-USD`,side:c,size:Math.random()*5+.5,entryPrice:m,markPrice:m,liquidationPrice:m*(1-(c==="long"?.15:-.15)/5),unrealizedPnl:0,realizedPnl:0,leverage:5,timestamp:o,positionValue:0})}}t={positions:i,createdAt:o,lastPriceUpdate:o,lastNewPositionCheck:o,closedPositionIds:new Set},g.set(e,t)}return o-t.lastPriceUpdate>=2e3&&(t.positions=t.positions.map(i=>{const r=(Math.random()-.5)*.01,n=i.markPrice*(1+r),a=(n-i.entryPrice)*i.size*(i.side==="long"?1:-1);return{...i,markPrice:n,unrealizedPnl:a,positionValue:i.size*n}}),t.lastPriceUpdate=o),t.positions.filter(i=>!t.closedPositionIds.has(i.id))},h=e=>{const s=f(e),o=1e7+s.reduce((i,r)=>i+r.unrealizedPnl,0),t=s.reduce((i,r)=>i+r.size*r.entryPrice,0);return{address:e,balances:[{asset:"USDC",total:o,available:o-t,inPositions:t}],totalEquity:o,freeCollateral:o-t}},T=()=>{const e={};return w.forEach(s=>{const o=y[s.symbol],t=o*(1+(Math.random()-.5)*.02),i=t-o;e[s.symbol]={lastPrice:t,volume24h:Math.floor(Math.random()*1e4+1e3),funding:(Math.random()-.5)*.05,openInterest:Math.floor(Math.random()*5e3+1e3),change24hPct:i/o*100,change24hAbs:i}}),e},u=new Map,C=(e,s,o,t,i)=>{const r=o==="buy",n=r?"long":"short",a=i||45e3,c=a*(1+(Math.random()-.5)*.01);return{id:`order-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,market:s.includes("-")?s:`${s}-USD`,side:n,size:t,entryPrice:i||a,markPrice:c,liquidationPrice:(i||a)*(1-(r?.1:-.1)/5),unrealizedPnl:0,realizedPnl:0,leverage:5,timestamp:Date.now(),positionValue:t*i}};function $(){const e=["dexAbstraction","unifiedAccount"],s=Math.floor(Math.random()*e.length);return e[s]}const b={async getMarkets(){return await new Promise(e=>setTimeout(e,100)),[...w]},async getMarketStats(){return await new Promise(e=>setTimeout(e,100)),T()},async getOrderBook(e){return await new Promise(s=>setTimeout(s,100)),S(e)},async getTrades(e,s=20){return await new Promise(o=>setTimeout(o,100)),k(e).slice(0,s)},async getPositions(e){await new Promise(t=>setTimeout(t,100));const s=u.get(e)||[],o=s.map(t=>t.position);if(o.length>0){console.log(`[MOCK-getPositions] User ${e.slice(0,6)}... - Found ${o.length} copied positions`);const t=o.map(r=>{const n=(Math.random()-.5)*.01,a=r.markPrice*(1+n),c=(a-r.entryPrice)*r.size*(r.side==="long"?1:-1),d={...r,markPrice:a,unrealizedPnl:c,positionValue:r.size*a};return console.log(`[MOCK-getPositions] Updated ${r.market}: Mark ${r.markPrice.toFixed(4)} â†’ ${a.toFixed(4)}`),d}),i=s.map((r,n)=>({...r,position:t[n]}));return u.set(e,i),t}if(O(e)){const t=f(e,!0);return console.log(`[MOCK-getPositions] Trader ${e.slice(0,6)}... - Generated ${t.length} positions`),t}return console.log(`[MOCK-getPositions] User ${e.slice(0,6)}... - No positions`),[]},async getAccountInfo(e){return await new Promise(s=>setTimeout(s,100)),h(e)},async getSpotAccountInfo(e){return await new Promise(s=>setTimeout(s,100)),h(e)},createExchangeClient(e){const s=e?.address||"0xmock";return{order:async o=>(console.log("[MOCK-EXCHANGE] order() called with orders:",o),b.order(s,o)),modifyOrder:async o=>({status:"ok",response:[]}),cancelOrder:async o=>({status:"ok",response:[]}),updateLeverage:async()=>({status:"ok"}),updateIsolatedMargin:async()=>({status:"ok"})}},async getUserFills(e,s=!0){return await new Promise(o=>setTimeout(o,100)),[]},async getExtraAgents(e){return await new Promise(s=>setTimeout(s,100)),{}},async storeOrder(e,s){const o=P.get(e)||[];o.push({...s,id:`order-${Date.now()}-${Math.random().toString(36).substring(2,11)}`,status:"pending",timestamp:Date.now()}),P.set(e,o)},async order(e,s){console.log(`[MOCK-order] Called for address=${e.slice(0,6)}... with ${s.length} orders`),await new Promise(t=>setTimeout(t,200));const o=[];for(const t of s){const i=`order-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;console.log("[MOCK-order] Processing orderConfig:",JSON.stringify(t).slice(0,200));let r="BTC-USD",n="buy",a=1,c=45e3;if(t.t){const l=t.t;l.asset!==void 0&&(r=`ASSET${l.asset}-USD`),l.isBuy!==void 0&&(n=l.isBuy?"buy":"sell"),l.sz!==void 0&&(a=l.sz),l.px!==void 0&&(c=l.px)}else t.market&&(r=t.market.includes("-")?t.market:`${t.market}-USD`),t.side&&(n=t.side==="long"||t.side==="buy"?"buy":"sell"),t.size!==void 0&&(a=t.size),t.price!==void 0&&(c=t.price);r.includes("-")||(r=`${r}-USD`),console.log(`[MOCK-order] Extracted: market=${r}, side=${n}, size=${a}, price=${c}`);const d=C(e,r,n,a,c),m=u.get(e)||[],M=n==="buy"?"long":"short",p=m.findIndex(l=>l.position.market===r&&l.position.side===M);p!==-1?(m[p]={orderId:i,position:d,timestamp:Date.now()},console.log(`[MOCK-order] Position UPDATED: ${d.market} ${d.side} (replaced existing), total positions for address now=${m.length}`)):(m.push({orderId:i,position:d,timestamp:Date.now()}),console.log(`[MOCK-order] Position STORED: ${d.market} ${d.side} size=${d.size}, total positions for address now=${m.length}`)),u.set(e,m),o.push({status:"ok",response:{type:"order",oid:i,statuses:["filled"]}})}return console.log(`[MOCK-order] Returning success for ${o.length} orders`),{status:"ok",response:o}},async getOrders(e){return await new Promise(s=>setTimeout(s,100)),P.get(e)||[]},clearOrders(e){e?P.delete(e):P.clear()},closePosition(e,s){const o=g.get(e);o&&(o.closedPositionIds.add(s),console.log(`[MOCK-closePosition] Closed position ${s} for ${e.slice(0,6)}... (will stay closed)`));const i=(u.get(e)||[]).filter(r=>r.position.id!==s);i.length>0?u.set(e,i):u.delete(e)},async getUserAbstraction(){return await new Promise(s=>setTimeout(s,100)),$()}},z=[{address:"0x1111111111111111111111111111111111111111",name:"ProTrader",leverage:5,riskPerTrade:2},{address:"0x2222222222222222222222222222222222222222",name:"SwingTrader",leverage:3,riskPerTrade:1.5},{address:"0x3333333333333333333333333333333333333333",name:"ScalpMaster",leverage:2,riskPerTrade:1}],O=e=>z.some(s=>s.address.toLowerCase()===e.toLowerCase());export{b as mockClient};
